<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Viperman</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <!-- HAMMER - TOUCH EVENT LIBRARY -->
        <script src="https://hammerjs.github.io/dist/hammer.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
<div id='container' style="width: 100vw; height: 100vh; overflow: hidden;">
    <canvas id="renderCanvas"></canvas>
    <p id='fps' style="position: absolute; top: 80%; left: 40%; font-size: 50px; color: red;">1111</p>
</div> 
    <script>

var fps = document.getElementById('fps');
        setInterval(function(){ 
           fps.innerHTML = engine.getFps()
        //    console.log(scene.getAnimationRatio())
            }, 1000)

        //GET CANVAS
        var container = document.getElementById("container");
        var canvas = document.getElementById("renderCanvas");

        
        var startAgain = document.createElement("DIV");
        if(document.body.clientWidth > document.body.clientHeight){
            startAgain.style.width = "40%"
            startAgain.style.height = "10%"
            startAgain.style.left = '30%';
            startAgain.style.top = '30%';
        } else {
            startAgain.style.width = "70%"
            startAgain.style.height = "5%"
            startAgain.style.left = '15%';
            startAgain.style.top = '30%';
        }
        startAgain.style.position = 'absolute';
        startAgain.style.backgroundImage = 'url("img/startAgain2.png")';
        startAgain.style.backgroundSize = 'cover';
        startAgain.style.backgroundPosition = 'center';
        startAgain.style.display = 'none';
        container.append(startAgain);

        startAgain.onclick = () => {
            // startAgain.style.display = 'none';
            location.reload();
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };

        function createScene() {
            var scene = new BABYLON.Scene(engine);

            

            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, -1), scene);
            light.intensity = 1;
            var light2 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 1), scene);
            light2.intensity = 1;
            var light3 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, -1, -1), scene);
            light3.intensity = 1;
            var light4 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, -1, 1), scene);
            light4.intensity = 1;

            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 3, -5));

            //test
            // var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 30, 20), scene);
            // camera.attachControl(canvas, true);

            //GUI
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            //START PANEL
            //start image
            var viperDemo = new BABYLON.GUI.Image("", "img/vipermanDemo2.png");
            if(document.body.clientWidth > document.body.clientHeight){
                viperDemo.width = 0.8;
                viperDemo.height = 0.4;
            } else {
                viperDemo.width = 0.9;
                viperDemo.height = 0.25;
                viperDemo.top = 150 + 'px';
            }
            viperDemo.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            viperDemo.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            // viperDemo.notRenderable = true;
            advancedTexture.addControl(viperDemo);
            //start game image
            var startGame = new BABYLON.GUI.Image("", "img/startGame2.png");
            if(document.body.clientWidth > document.body.clientHeight){
            startGame.width = 0.4;
            startGame.height = 0.1;
            } else {
                startGame.width = 0.7;
                startGame.height = 0.1;
            }
            startGame.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            startGame.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            startGame.isPointerBlocker = true;
            // startGame.notRenderable = true;
            advancedTexture.addControl(startGame);
            //display pause sign
            var pauseGameSign = new BABYLON.GUI.Image("", "img/pause2.png");
            if(document.body.clientWidth > document.body.clientHeight){
                pauseGameSign.width = 0.4;
                pauseGameSign.height = 0.1;
            } else {
                pauseGameSign.width = 0.7;
                pauseGameSign.height = 0.1;
            }
            pauseGameSign.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            pauseGameSign.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            pauseGameSign.notRenderable = true;
            advancedTexture.addControl(pauseGameSign);
            //game over sign
            var gameOverSign = new BABYLON.GUI.Image("", "img/gameOver2.png");
            if(document.body.clientWidth > document.body.clientHeight){
                gameOverSign.width = 0.4;
                gameOverSign.height = 0.1;
            } else {
                gameOverSign.width = 0.7;
                gameOverSign.height = 0.1;
            }
            gameOverSign.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            gameOverSign.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            gameOverSign.notRenderable = true;
            advancedTexture.addControl(gameOverSign);
            //rotate around viper before start and at the end
            function rotateAroundMesh(){
                scene.onBeforeCameraRenderObservable.add(()=>{
                    if (!gameRunning){
                        scene.activeCamera.alpha += 0.002 * scene.getAnimationRatio();
                    }
                })
            }
             //pause game button
            var pauseGameButton = new BABYLON.GUI.Image("", "img/pauseButton.png");
            if(document.body.clientWidth > document.body.clientHeight){
                pauseGameButton.width = 0.025;
                pauseGameButton.height = 0.05;
                pauseGameButton.top = 20 + 'px';
                pauseGameButton.left = -20 + 'px';
            } else {
                pauseGameButton.width = 0.1;
                pauseGameButton.height = 0.05;
                pauseGameButton.top = 30 + 'px';
                pauseGameButton.left = -30 + 'px';
            }
            pauseGameButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            pauseGameButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            pauseGameButton.isPointerBlocker = true;
            advancedTexture.addControl( pauseGameButton);
            //start game from pause button
            var startGameFromPauseButton = new BABYLON.GUI.Image("", "img/playButton.png");
            if(document.body.clientWidth > document.body.clientHeight){
                startGameFromPauseButton.width = 0.025;
                startGameFromPauseButton.height = 0.05;
                startGameFromPauseButton.top = 20 + 'px';
                startGameFromPauseButton.left = -20 + 'px';
            } else {
                startGameFromPauseButton.width = 0.1;
                startGameFromPauseButton.height = 0.05;
                startGameFromPauseButton.top = 30 + 'px';
                startGameFromPauseButton.left = -30 + 'px';
            }
            startGameFromPauseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            startGameFromPauseButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            startGameFromPauseButton.isPointerBlocker = true;
            startGameFromPauseButton.notRenderable = true;
            advancedTexture.addControl(startGameFromPauseButton);

                        //LIFE AND COINS DISPLAY
            //lives display
            var lifesHolder = new BABYLON.GUI.Rectangle();
            lifesHolder.thickness = 0;
            if(document.body.clientWidth > document.body.clientHeight){
                lifesHolder.width = 0.04;
                lifesHolder.height = 0.04;
                lifesHolder.left = 20 + 'px';
                lifesHolder.top = 20 + 'px';
            } else {
                lifesHolder.width = 0.2;
                lifesHolder.height = 0.06;
                lifesHolder.left = 30 + 'px';
                lifesHolder.top = 30 + 'px';
            }
            lifesHolder.background = "black";
            lifesHolder.alpha = 0.4;
            lifesHolder.cornerRadius = 15;
            lifesHolder.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            lifesHolder.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            advancedTexture.addControl(lifesHolder);

            var livesBlock = new BABYLON.GUI.TextBlock();
            livesBlock.text = "x3";
            livesBlock.color = "#fff";
            if(document.body.clientWidth > document.body.clientHeight){
                livesBlock.fontSize = 25 + "px";
            } else {
                livesBlock.fontSize = 50 + "px";
            }
            livesBlock.alpha = 2.5;
            lifesHolder.addControl(livesBlock);
            //coins display
            var coinsHolder = new BABYLON.GUI.Rectangle();
            coinsHolder.thickness = 0;
            if(document.body.clientWidth > document.body.clientHeight){
                coinsHolder.width = 0.07;
                coinsHolder.height = 0.04;
                coinsHolder.left = 20 + 'px';
                coinsHolder.top = 70 + 'px';
            } else {
                coinsHolder.width = 0.28;
                coinsHolder.height = 0.06;
                coinsHolder.left = 30 + 'px';
                coinsHolder.top = 150 + 'px';
            }
            coinsHolder.background = "black";
            coinsHolder.alpha = 0.4;
            coinsHolder.cornerRadius = 15;
            coinsHolder.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            coinsHolder.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            advancedTexture.addControl(coinsHolder);

            var imageLogo = new BABYLON.GUI.Image("imageLogo", "img/sandviperLogo.png");
            if(document.body.clientWidth > document.body.clientHeight){
                imageLogo.width = 0.5;
                imageLogo.height = 2;
                imageLogo.left = -25 + 'px';
            } else {
                imageLogo.width = 0.5;
                imageLogo.height = 2;
                imageLogo.left = -50 + 'px';
            }
            imageLogo.alpha = 2.5;
            coinsHolder.addControl(imageLogo);

            var coinBlock = new BABYLON.GUI.TextBlock();
            coinBlock.text = ": 0";
            coinBlock.color = "#fff";
            if(document.body.clientWidth > document.body.clientHeight){
                coinBlock.fontSize = 25 + "px";
                coinBlock.left = 15 + 'px';
            } else {
                coinBlock.fontSize = 50 + "px";
                coinBlock.left = 35 + 'px';
            }
            coinBlock.alpha = 2.5;
            coinsHolder.addControl(coinBlock);

            //MUSIC IN THE GAME
            // var gameMusic = new BABYLON.Sound("gameMusic", "sounds/TRON Legacy (End Titles).mp3", scene, null, {
            //     loop: true,
            //     autoplay: true
            // });

            // HDR texture of background
            var hdrBcgRefTexture = new BABYLON.HDRCubeTexture("https://raw.githubusercontent.com/veljko85/viperman/ghpages/textures/shangai.hdr", scene, 128);

            // Skybox
            var hdrSkybox = BABYLON.Mesh.CreateBox("hdrSkyBox", 5000.0, scene);
            var hdrSkyboxMaterial = new BABYLON.PBRMaterial("skyBox", scene);
            hdrSkyboxMaterial.backFaceCulling = false;
            hdrSkyboxMaterial.reflectionTexture = hdrBcgRefTexture.clone();
            hdrSkyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            hdrSkyboxMaterial.microSurface = 1.0;
            hdrSkyboxMaterial.cameraExposure = 0.66;
            hdrSkyboxMaterial.cameraContrast = 1.66;
            hdrSkyboxMaterial.disableLighting = true;
            hdrSkybox.material = hdrSkyboxMaterial;
            hdrSkybox.infiniteDistance = true;
            
            //GIVE GLOW TO GLOWING OBJ
            var glow = new BABYLON.GlowLayer("glow", scene);
            glow.intensity = 0.8;

            var speedGround = BABYLON.MeshBuilder.CreateGround("speedGround", {width: 2, height: 8}, scene);
            speedGround.position = new BABYLON.Vector3(-3,0.05,10);
            var speedGroundmat = new BABYLON.StandardMaterial("speedGroundmat", scene);
            var speedTex = new BABYLON.Texture("img/speedArrows.png", scene);
            speedTex.hasAlpha = true;
            speedGroundmat.diffuseTexture = speedTex;
            speedGroundmat.useAlphaFromDiffuseTexture = true;
            speedGroundmat.backFaceCulling = false;
            speedGroundmat.emissiveColor = new BABYLON.Color3.FromHexString('#ff0000')
            speedGround.material = speedGroundmat;
            speedGround.isVisible = false;

            speedGrounds = [];

            function createSpeedGround(speedGroundPositionX, speedGroundPositionZ){
                var newSpeedGround = speedGround.createInstance("newSpeedGround");
                speedGrounds.push(newSpeedGround);
                newSpeedGround.position = new BABYLON.Vector3(speedGroundPositionX, 0, speedGroundPositionZ);
                speedTrackCollider(newSpeedGround)
            }

            
            //POSITION Z OF THE ELEMNENTS OF GAME
            var posZ = 0;
            //FOOES
            function aniLaserWallWidth(mesh){
                    const anim= new BABYLON.Animation("aniLaserWallWidth", "scaling", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    anim.setKeys([
                        { frame: 0, value: new BABYLON.Vector3(1, 1, 1) },
                        // { frame: 10, value: -1 },
                        // { frame: 18, value: -0.5 },
                        // { frame: 20, value: -0.5 },
                        { frame: 60, value: new BABYLON.Vector3(3, 3, 3) },
                    ]);
                    mesh.animations = [];
                    mesh.animations.push(anim);
                    return scene.beginAnimation(mesh, 0, 60, false);
            }
            function aniSimpleLaserWall(mesh){
                const anim= new BABYLON.Animation("aniSimpleLaserWall", "position.y", 45, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                anim.setKeys([
                    { frame: 0, value: 0 },
                    // { frame: 10, value: -1 },
                    // { frame: 18, value: -0.5 },
                    // { frame: 20, value: -0.5 },
                    { frame: 30, value: -1.5 },
                ]);
                mesh.animations = [];
                mesh.animations.push(anim);
                return scene.beginAnimation(mesh, 0, 30, false);
            }
            //animate the mesh when it hits fooes to blink
            function visColAnim(mesh){
                const anim= new BABYLON.Animation("visColAnim", "isVisible", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                const colKeys = [
                { frame: 0, value: 1 },
                    { frame: 5, value: false },
                    { frame: 10, value: true },
                    { frame: 15, value: false },
                    { frame: 20, value: true },
                    { frame: 25, value: false },
                    { frame: 30, value: true },
                    { frame: 35, value: false },
                ]; 
                anim.setKeys(colKeys);
                mesh.animations = [];
                mesh.animations.push(anim);
                return scene.beginAnimation(mesh, 0, 35, false);
            }
            //animate the mesh when it hits fooes to go back few steps
            function animPosZMeshCollision(mesh){
                const anim= new BABYLON.Animation("animPosZMeshCollision", "position.z", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                anim.setKeys([
                    {frame: 0, value: mesh.position.z},
                    {frame: 5, value: mesh.position.z - 3},
                    {frame: 30, value: mesh.position.z - 3},
                ]);
                mesh.animations = [];    
                mesh.animations.push(anim);
                return scene.beginAnimation(mesh, 0, 60, false);
            }

            // var pillarMat = new BABYLON.StandardMaterial("pillarMat", scene);
            // var pillarTexture = new BABYLON.Texture("textures/pillar3.png", scene);
            // pillarMat.diffuseTexture = pillarTexture;

            // var faceUV = new Array(6);

            // for (var i = 0; i < 4; i++) {
            //     faceUV[i] = new BABYLON.Vector4( 0, 1/6, 1, 1);
            // }
            // faceUV[4] = new BABYLON.Vector4( 1/6, 0, 1, 1);
            // faceUV[5] = new BABYLON.Vector4( 1/6, 0, 1, 1);

            var options = {
                width: 0.1, 
                height: 1.4, 
                depth: 0.1,
                // faceUV: faceUV,
                // wrap: true
            };

            var laserWallUpperHolderLeft = BABYLON.MeshBuilder.CreateBox('laserWallUpperHolderLeft', options, scene);
            laserWallUpperHolderLeft.position = new BABYLON.Vector3(-1.5,0.8,0);
            // laserWallUpperHolderLeft.material = pillarMat;

            var laserWallUpperHolderRight = laserWallUpperHolderLeft.clone("laserWallUpperHolderRight");
            laserWallUpperHolderRight.position.x = 1.5;

            var laserWall = BABYLON.MeshBuilder.CreatePlane("laserWall", {height:1.4, width: 2.9});
            laserWall.position = new BABYLON.Vector3(0,0.8,0);
            var laserWallmat = new BABYLON.StandardMaterial("laserWallmat", scene);
            var laserWalltex = new BABYLON.Texture("img/laserWall2.png", scene);
            laserWalltex.hasAlpha = true;
            laserWallmat.diffuseTexture = laserWalltex;
            laserWallmat.useAlphaFromDiffuseTexture = true;
            laserWallmat.backFaceCulling = false;
            laserWallmat.emissiveColor = new BABYLON.Color3.FromHexString('#DF740C')
            laserWall.material = laserWallmat;

            var simpleLaserWall = BABYLON.Mesh.MergeMeshes([laserWall, laserWallUpperHolderRight, laserWallUpperHolderLeft], true, true, undefined, false, true);
            simpleLaserWall.position = new BABYLON.Vector3(0,0,10)
            simpleLaserWall.isVisible = false;

            //array to put fooes
            fooes = [];
            //function to create simple wall
            function createSimpleLaserWall(SimpleLaserWallLanePositionX, SimpleLaserWallLanePositionZ, wideOfWall){      
                var newSimpleLaserWall = simpleLaserWall.createInstance("simpleLaserWall");
                fooes.push(newSimpleLaserWall);
                newSimpleLaserWall.position = new BABYLON.Vector3(SimpleLaserWallLanePositionX, 0, SimpleLaserWallLanePositionZ);
                newSimpleLaserWall.scaling = new BABYLON.Vector3(wideOfWall,1,1)
                fooesCollider(newSimpleLaserWall)
            }
            // var randNum = () =>{
            //     return Math.floor(Math.random() * 3);
            // }
                
            // var fooesLanePositions = [-3, 0, 3]
            // var laserWallWidth = () => {
            // }

            //COINS
            BABYLON.SceneLoader.ImportMeshAsync("", "", "meshes/logo.glb").then((result) => { 
                var coinLogo = result.meshes[0];
                coinLogo.position = new BABYLON.Vector3(0, 0, 0)
                var coinLogoMat = new BABYLON.StandardMaterial("coinLogoMat", scene);
                coinLogoMat.emissiveColor = new BABYLON.Color3.FromHexString('#ffffff');
                scene.getMeshByName("Plane").material = coinLogoMat;
                scene.getMeshByName("Plane").isVisible = false;
                coinLogo.rotationQuaternion = null;
                coinLogo.checkCollisions = true;
                // createCoinsForTielOne(0)
                // createCoinsForTielTwo(300)
            })
            coins = [];
            function createCoinLane(coinLanePositionX, coinLanePositionZ){
                for (var i = 1; i < 11; i++) {
                    var newCoin = scene.getMeshByName("Plane").createInstance("coin" + i);
                    coins.push(newCoin);

                    newCoin.position = new BABYLON.Vector3(coinLanePositionX, 0.5, (coinLanePositionZ + i * 3));
                    coinsCollider(newCoin)
                }
            }
            function createCoinsForTielOne(coinPosZ){
                // createCoinLane(3, coinPosZ + 30);
                createCoinLane(-3, coinPosZ + 30);
                // createCoinLane(0, coinPosZ + 60);
                // createCoinLane(-3, coinPosZ + 60);
                // createCoinLane(3, coinPosZ + 100);
                // createCoinLane(0, coinPosZ + 100);
            }
            function createCoinsForTielTwo(coinPosZ){
                createCoinLane(0.01, coinPosZ + 10);
                createCoinLane(3, coinPosZ + 100);
                createCoinLane(-3, coinPosZ + 150);
            }
                
            //CREATE PEACES FOR GROUND/BRIDGE/TRACK
            //main platform for running
            var bridgeGround = BABYLON.MeshBuilder.CreateGround("ground", {width: 9, height:150}, scene);
            var bridgeMat = new BABYLON.PBRMaterial("bridgeMat", scene);
            bridgeMat.reflectionTexture = hdrBcgRefTexture;
            bridgeMat.refractionTexture = hdrBcgRefTexture;
            bridgeMat.reflectionTexture.level = 1;
            bridgeMat.specularPower = 150;
            bridgeMat.indexOfRefraction = 0.52;
            bridgeMat.alpha = 0.8;
            bridgeMat.directIntensity = 0.0;
            bridgeMat.environmentIntensity = 0.7;
            bridgeMat.cameraExposure = 0.66;
            bridgeMat.cameraContrast = 1.66;
            bridgeGround.material = bridgeMat;
            // bridgeGround.position.z = 140;
            bridgeGround.position = new BABYLON.Vector3(0,0,70)
            bridgeGround.isVisible = true;

            //create bridge plane to go bellow
            var bridgeLayout = BABYLON.MeshBuilder.CreateGround("ground", {width: 10.5, height:150}, scene);
            bridgeLayout.position.z = 70;
            bridgeLayout.position.y = -0.5;
            var bridgeLayoutMat = new BABYLON.StandardMaterial("bridgeLayoutMat", scene);
            bridgeLayoutMat.diffuseTexture = new BABYLON.Texture("img/podloga3.jpg", scene);
            bridgeLayoutMat.diffuseTexture.uScale = 1;
            bridgeLayoutMat.diffuseTexture.vScale = 50;
            bridgeLayout.material = bridgeLayoutMat;

            //create glass walls
            var glassWall = new BABYLON.MeshBuilder.CreateBox("glassWall", {width: 0.05, height: 3, depth: 150}, scene);
            glassWall.position = new BABYLON.Vector3(-5,1.5,70)
            var glassWallMat = new BABYLON.PBRMaterial("glassWallMat", scene);
            glassWallMat.reflectionTexture = hdrBcgRefTexture;
            glassWallMat.refractionTexture = hdrBcgRefTexture;
            glassWallMat.linkRefractionWithTransparency = true;
            glassWallMat.indexOfRefraction = 0.52;
            glassWallMat.alpha = 0;
            glassWallMat.directIntensity = 0.0;
            glassWallMat.environmentIntensity = 0.7;
            glassWallMat.cameraExposure = 0.66;
            glassWallMat.cameraContrast = 1.66;
            glassWallMat.reflectivityColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            glassWallMat.albedoColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            glassWall.material = glassWallMat;
            // glassWall.isVisible = false;
            //other glass walls
            var glassWall2 = glassWall.clone("glassWall2");
            glassWall2.position.x = 5;

            //side walks
            var sideWalk = new BABYLON.MeshBuilder.CreateBox("sideWalk", {width: 1, height: 0.4, depth: 150}, scene);
            var sideWalkMat = new BABYLON.StandardMaterial("sideWalkMat", scene);
            sideWalkMat.diffuseColor = new BABYLON.Color3.FromHexString('#00cdcd')
            sideWalkMat.emissiveColor = new BABYLON.Color3.FromHexString('#00cdcd');
            sideWalk.material = sideWalkMat;
            sideWalk.position = new BABYLON.Vector3(-5,0,70)
            //other sidewalk
            var sideWalk2 = sideWalk.clone("sideWalk2");
            sideWalk2.position.x = 5;
            //side walks glass part
            var sideWalkGlassPart = new BABYLON.MeshBuilder.CreateBox("sideWalkGlassPart", {width: 0.1, height: 0.1, depth:150}, scene);
            sideWalkGlassPart.material = glassWallMat;
            sideWalkGlassPart.position = new BABYLON.Vector3(-4.5,0.2,70)
            //other sidewalk glass part
            var sideWalkGlassPart2 = sideWalkGlassPart.clone("sideWalkGlassPart2");
            sideWalkGlassPart2.position.x = 4.5;
                
            //running tracks
            var runningTrack = new BABYLON.MeshBuilder.CreateBox("runningTrack", {width: 0.2, height: 0.1, depth: 150}, scene);
            var runningTrackMat = new BABYLON.StandardMaterial("runningTrackMat", scene);
            runningTrackMat.diffuseColor = new BABYLON.Color3.FromHexString('#00cdcd')
            runningTrackMat.emissiveColor = new BABYLON.Color3.FromHexString('#00cdcd');
            runningTrack.material = runningTrackMat;
            runningTrack.position = new BABYLON.Vector3(-1.5,0,70)
            //right running track
            var runningTrackRight = runningTrack.clone("runningTrackRight");
            runningTrackRight.position.x = 1.5;
            //running tracks glass part
            var runningGlassPart = sideWalkGlassPart.clone("runningGlassPart");
            runningGlassPart.position = new BABYLON.Vector3(-1.5,0.05,70)
            //running tracks glass part right
            var runningGlassPartRight = sideWalkGlassPart.clone("runningGlassPartRight");
            runningGlassPartRight.position = new BABYLON.Vector3(1.5,0.05,70)

            var bridgeMesh = BABYLON.Mesh.MergeMeshes([bridgeLayout, glassWall, glassWall2, sideWalk, sideWalk2, sideWalkGlassPart, sideWalkGlassPart2, runningTrack, runningTrackRight, runningGlassPart, runningGlassPartRight], true, true, undefined, false, true);
            bridgeMesh.isVisible = true;

            var runningTracks = [];
            var grounds = []
                
            function createTrackOne(){
                var bridgeMeshInstance = bridgeMesh.createInstance('bridgeMeshInstance');
                runningTracks.push(bridgeMeshInstance)
                bridgeMeshInstance.position = new BABYLON.Vector3(0,0,posZ)
                var bridgeGroundInstance = bridgeGround.createInstance('bridgeGroundInstance');
                bridgeGroundInstance.position = new BABYLON.Vector3(0,0,posZ + 70)
                grounds.push(bridgeGroundInstance)
                addGravity(bridgeGroundInstance)
                posZ += 150
            }
          
            //game info
            var gameRunning = false;
            var running = false;
            var highlandOnSideLeft = false;
            var highlandOnSideRight = false;
            var playerSpeed = 0.3;
            var lives = 3;
            var colectedCoins = 0;

            //FAKE MESHES AND ELLIPSOID
            //main fake mesh for camera
            var fakeMesh = new BABYLON.MeshBuilder.CreateBox("fakeMesh", {width: 0.2, height: 0.2, depth: 0.2}, scene);
            var fakeMeshPosY = 1.8;
            fakeMesh.position = new BABYLON.Vector3(0,fakeMeshPosY,0)
            fakeMesh.isVisible = true;
            camera.target = fakeMesh;
            //fake mesh for elipsoid
            var fakeMeshEllipse = new BABYLON.MeshBuilder.CreateBox("fakeMeshEllipse", {width: 0.2, height: 0.2, depth: 0.2}, scene);
            fakeMeshEllipse.position = new BABYLON.Vector3(0,-0.8,0)
            fakeMeshEllipse.parent = fakeMesh;
            fakeMeshEllipse.isVisible = true;
            //Create Ellipsoid around mesh
            var a = 0.5;
            var b = 1;
            var points = [];
            for(var theta = -Math.PI/2; theta < Math.PI/2; theta += Math.PI/36) {
                points.push(new BABYLON.Vector3(0, b * Math.sin(theta), a * Math.cos(theta)));
            }
            var ellipse = [];
            ellipse[0] = BABYLON.MeshBuilder.CreateLines("e", {points:points}, scene);
            ellipse[0].isVisible = true;
            ellipse[0].parent = fakeMeshEllipse;
            ellipse[0].rotation.y = Math.PI * 2;
            for(var i = 1; i < 3; i++) {
                ellipse[i] = ellipse[0].createInstance("el" + i);
                ellipse[i].parent = fakeMeshEllipse;
                ellipse[i].isVisible = true;
                ellipse[i].checkCollisions = true;
            }
            ellipse[1].rotation.y = Math.PI * 2 - 1.3;
            ellipse[2].rotation.y = Math.PI * 2 + 1.3;
            //IMPORT MESHES
            //viperman
            BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/veljko85/glbModels/gh-pages/viperman/", "viperman.glb").then((result) => {
            // BABYLON.SceneLoader.ImportMeshAsync("", "", "meshes/viperman.glb").then((result) => { 
                var viperman =  result.meshes[0];
                viperman.parent = fakeMesh;
                viperman.position.y = -1.8;
                scene.animationGroups.find(a => a.name === 'finish').setWeightForAllAnimatables(0);
                // for (let i = 0; i < result.meshes.length; i++) {
                //     result.meshes[i].isVisible = false
                // }
            })

            //MOVMENT
            //animation for moving left and right
            function moveViperAnim(mesh, pos, direction){
                const anim= new BABYLON.Animation("moveLeftAnim", "position.x", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                anim.setKeys([
                    { frame: 0, value: pos },
                    { frame: 15, value: direction },
                ]);
                mesh.animations = [];
                mesh.animations.push(anim);
                return scene.beginAnimation(mesh, 0, 15, false);
            }
            //function to move left
            function viperMoveLeft(){
                if (fakeMesh.position.x == 0 || fakeMesh.position.x == 3) {
                    moveViperAnim(fakeMesh, fakeMesh.position.x, fakeMesh.position.x-3)
                    fakeMesh.addRotation(0,-0.3,0)
                    setTimeout(function(){ 
                        fakeMesh.addRotation(0,0.3,0)
                    }, 250)
                }
            }
            //function to move right
            function viperMoveRight(){
                if (fakeMesh.position.x == 0 || fakeMesh.position.x == -3) {
                    moveViperAnim(fakeMesh, fakeMesh.position.x, fakeMesh.position.x+3)
                    fakeMesh.addRotation(0,0.3,0)
                    setTimeout(function(){ 
                        fakeMesh.addRotation(0,-0.3,0)
                    }, 250)
                }
            }
            //animation for jumping
            function aniPosY(mesh, meshPosition){
                const anim= new BABYLON.Animation("animPosY", "position.y", 45, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                anim.setKeys([
                    { frame: 0, value: meshPosition + 0 },
                    { frame: 10, value: meshPosition + 2.5 },
                    { frame: 20, value: meshPosition + 3 },
                    { frame: 30, value: meshPosition + 3.5 },
                ]);
                mesh.animations = [];
                mesh.animations.push(anim);
                return scene.beginAnimation(mesh, 0, 20, false);
            }
            //function for jumping
            function viperJump(){
                if (fakeMesh.position.x == 0 || fakeMesh.position.x == -3 || fakeMesh.position.x == 3) {
                    //jumpSound.play();
                    aniPosY(fakeMesh, fakeMeshPosY)
                    scene.animationGroups.find(a => a.name === 'jump').start(false, 1, 0);
                    scene.animationGroups.find(a => a.name === 'run').setWeightForAllAnimatables(0);
                    running = false;
                    setTimeout(function(){ 
                        running = true;
                        scene.animationGroups.find(a => a.name === 'run').setWeightForAllAnimatables(1);
                        scene.animationGroups.find(a => a.name === 'jump').stop(false, 1, 0);
                    }, 680)
                }
            }
            //function for sliding
            function viperSlide(){
                if (fakeMesh.position.x == 0 || fakeMesh.position.x == -3 || fakeMesh.position.x == 3) {
                    scene.animationGroups.find(a => a.name === 'slide').start(false, 1, 0);
                    scene.animationGroups.find(a => a.name === 'run').setWeightForAllAnimatables(0);
                    fakeMeshEllipse.position.y = -1.8;
                    running = false;
                    setTimeout(function(){ 
                        running = true;
                        fakeMeshEllipse.position.y = -0.8;
                        scene.animationGroups.find(a => a.name === 'run').setWeightForAllAnimatables(1);
                    }, 1580)
                }
            }
            
            //EVENT LISTENERS
            //key event listeners
            function lintenKeysEvents(){
                document.onkeydown = checkKey;
                function checkKey(event) {
                    if (event.keyCode == 38 && running) {
                        viperJump();
                    }
                    //jump on ins0
                    if (event.keyCode == 96 && running) {
                        viperJump();
                    }
                    //viper move left
                    if (event.keyCode == 37 && running && !highlandOnSideRight) {
                        viperMoveLeft();
                    }
                    //viper move right
                    if (event.keyCode == 39 && running && !highlandOnSideLeft) {
                        viperMoveRight();
                    }
                    //viper slide down
                    if (event.keyCode == 40 && fakeMeshEllipse.position.y == -0.8 && running) {
                        viperSlide();
                    }
                }
            }
            //touch event listeners with hammer
            function lintenTouchEvents(){
                var hammertime = new Hammer(canvas);
                hammertime.get('swipe').set({ direction: Hammer.DIRECTION_ALL });
                hammertime.on("swipeleft swiperight swipeup swipedown tap press", function(ev) {
                    if (ev.type == 'swipeup'  && running){
                        viperJump(); 
                    } else if (ev.type == 'swipedown'  && running) {
                        viperSlide();
                    }
                    else if (ev.type == 'swipeleft'  && running && !highlandOnSideRight) {
                        viperMoveLeft();
                    }
                    else if (ev.type == 'swiperight'  && running && !highlandOnSideLeft) {
                        viperMoveRight();
                    }
                });
            }
            
            function gameRender(){
                //loop track and elements creation
                if (runningTracks.length < 2) {
                    createCoinsForTielOne(posZ)
                    createSimpleLaserWall(0, posZ, 1);
                    // createSpeedGround(3, posZ + 20)
                    // createSpeedGround(-3,posZ + 50)
                    createSpeedGround(0,posZ + 100)
                    createTrackOne()
                }
                //dispose track
                for (let i = 0; i < runningTracks.length; i++) {
                    if ((fakeMesh.position.z - 160) > runningTracks[i].position.z){
                        runningTracks[i].dispose();
                        grounds[i].dispose();
                        runningTracks.splice(i, 1);
                        grounds.splice(i, 1);
                    }
                }
                //dispose fooes
                if (fooes.length > 0) {
                    for (let i = 0; i < fooes.length; i++) {
                        if ((fakeMesh.position.z - 10) > fooes[i].position.z){
                        fooes[i].dispose();
                        fooes.splice(i, 1);
                        }
                    }
                }
                //dispose coins
                if (coins.length > 0) {
                    for (let i = 0; i < coins.length; i++) {
                        if ((fakeMesh.position.z - 10) > coins[i].position.z){
                            coins[i].dispose();
                            coins.splice(i, 1);
                        }
                    }
                }
                //dispose speed ground
                if (speedGrounds.length > 0) {
                    for (let i = 0; i < speedGrounds.length; i++) {
                        if ((fakeMesh.position.z - 10) > speedGrounds[i].position.z){
                            speedGrounds[i].dispose();
                            speedGrounds.splice(i, 1);
                        }
                    }
                }
                // if (stairsArr.length > 0) {
                //     for (let i = 0; i < stairsArr.length; i++) {
                //         if ((fakeMesh.position.z - 110) > stairsArr[i].position.z){
                //             stairsArr[i].dispose(true, true);;
                //         }
                //     }
                // }
            }

            //function for mesh to start running
            function meshRunning(){
                //change running status
                running = true;
                gameRunning = true;
                if (fakeMesh.position.z < -4.9){
                    camera.setPosition(new BABYLON.Vector3(0, 3, -5));
                } else {
                    camera.setPosition(new BABYLON.Vector3(fakeMesh.position.x, fakeMeshPosY + 1.2, fakeMesh.position.z - 5));
                }
                //start running animation
                scene.animationGroups.find(a => a.name === 'run').start(true, 1, 0);
                //change viperman and fake mesh position z - move thrue space
                scene.beforeRender = function() {
                    fakeMesh.position.z += playerSpeed * scene.getAnimationRatio();
                    gameRender()
                };
            }

            function pauseGame(){ 
                    if (gameRunning){
                        running = false;
                        gameRunning = false;
                        scene.animationGroups.find(a => a.name === 'run').pause(true);
                        scene.beforeRender = function() {
                            fakeMesh.position.z += 0;
                        };
                        pauseGameButton.notRenderable = true;
                        startGameFromPauseButton.notRenderable = false;
                        pauseGameSign.notRenderable = false;
                    }
                }

            //start game from pause function
            function startGameFromPause(){ 
                if (!gameRunning){ 
                    gameRunning = true;
                    scene.animationGroups.find(a => a.name === 'run').pause(false);
                    scene.animationGroups.find(a => a.name === 'run').play(true);
                    meshRunning()
                    pauseGameButton.notRenderable = false;
                    startGameFromPauseButton.notRenderable = true;
                    pauseGameSign.notRenderable = true;
                }
            }
            //pause game
            pauseGameButton.onPointerClickObservable.add(function () {
                pauseGame();
            });
            //start game from pause
            startGameFromPauseButton.onPointerClickObservable.add(function () {
                startGameFromPause();
            });
            //rotate around the mesh at start and end of the game
            rotateAroundMesh()
            //START GAME
            startGame.onPointerClickObservable.add(function () {
                bridgeGround.isVisible = false;
                bridgeMesh.isVisible = false;
                createTrackOne()
                meshRunning();
                viperDemo.notRenderable = true;
                startGame.notRenderable = true;
                lintenKeysEvents();
                lintenTouchEvents();
            });

            //game over function
            function gameOver(){ 
                running = false;
                gameRunning = false;
                gameOverSign.notRenderable = false;
                scene.animationGroups.find(a => a.name === 'run').pause(true);
                scene.beforeRender = function() {
                    fakeMesh.position.z += 0;
                };
                startAgain.style.display = 'block';
            }
            
            
            //COLLIDERS
            //add collision and gravity to ground
            function addGravity(thisGorund){
                for (let f = 0; f < ellipse.length; f++) {
                    thisGorund.checkCollisions = true;
                    thisGorund.actionManager = new BABYLON.ActionManager(scene);
                    let actionGravityOn = new BABYLON.ExecuteCodeAction(
                        {
                            trigger: BABYLON.ActionManager.OnIntersectionExitTrigger, 
                            parameter: { 
                                mesh: thisGorund
                            }
                        },
                        (evt) => {
                            console.log('skocio')
                            scene.beforeRender = function() {
                                fakeMesh.position.z += playerSpeed * scene.getAnimationRatio();
                                if(fakeMesh.position.y > 1.81){
                                    fakeMesh.position.y -= 0.2;
                                }
                                gameRender()
                            };
                        }
                    );
                    let actionGravityOff = new BABYLON.ExecuteCodeAction(
                        {
                            trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, 
                            parameter: { 
                                mesh: thisGorund
                            }
                        },
                        (evt) => {
                            console.log('pao')
                            scene.beforeRender = function() {
                                fakeMesh.position.z += playerSpeed * scene.getAnimationRatio();
                                fakeMesh.position.y -= 0;
                                gameRender()
                            };
                        }
                    );
                    ellipse[f].actionManager.registerAction(actionGravityOff);
                    ellipse[f].actionManager.registerAction(actionGravityOn);
                }
            }
            //add collison to coins
            function coinsCollider(thisCoin){
                for (let j = 0; j < ellipse.length; j++) {
                        thisCoin.checkCollisions = true;
                        thisCoin.actionManager = new BABYLON.ActionManager(scene);
                        let action = new BABYLON.ExecuteCodeAction(
                            {
                                trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, 
                                parameter: { 
                                     mesh: thisCoin
                                }
                            },
                            (evt) => {
                                if (thisCoin.isVisible) { 
                                    colectedCoins += 1;
                                    // coinSound.play();
                                    coinBlock.text = ": " + colectedCoins;
                                    thisCoin.isVisible = false;
                                }
                            }
                        );  
                        ellipse[j].actionManager.registerAction(action);
                }
            }
            //add coolision to fooes
            function fooesCollider(thisFooe){
                for (let fe = 0; fe < ellipse.length; fe++) {
                    thisFooe.checkCollisions = true;
                    thisFooe.actionManager = new BABYLON.ActionManager(scene);
                    let action = new BABYLON.ExecuteCodeAction(
                        {
                            trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, 
                            parameter: { 
                                mesh: thisFooe
                            }
                        },
                        (evt) => {
                            if (thisFooe.checkCollisions){
                                //give mesh animation to go back on collision
                                animPosZMeshCollision(fakeMesh)
                                //goves mesh position after hit
                                fakeMesh.position.x = thisFooe.position.x;
                                fakeMesh.position.y = fakeMeshPosY;
                                visColAnim(thisFooe)
                                // fooes[i].isVisible = false;
                                thisFooe.checkCollisions = false;
                                lives -= 0;
                                livesBlock.text = "x" + lives;
                                // hitWallSound.play();
                                if (lives > 0){
                                    scene.animationGroups.find(a => a.name === 'run').stop(true, 1, 0)
                                    scene.animationGroups.find(a => a.name === 'hit_in').start(false, 1, 0)
                                    running = false;
                                    setTimeout(function(){
                                        scene.animationGroups.find(a => a.name === 'hit_in').stop(false, 1, 0)
                                        scene.animationGroups.find(a => a.name === 'run').start(true, 1, 0)
                                        running = true;
                                    }, 1000);
                                }
                                if (lives < 1){;
                                    scene.animationGroups.find(a => a.name === 'game_over').start(false, 1, 0)
                                    gameOver();
                                }
                            }
                        }
                    );  
                    ellipse[fe].actionManager.registerAction(action);
                }
            }
            //add collison to speed track
            function speedTrackCollider(thisSpeedGround){
                for (let j = 0; j < ellipse.length; j++) {
                    thisSpeedGround.checkCollisions = true;
                    thisSpeedGround.actionManager = new BABYLON.ActionManager(scene);
                    let action = new BABYLON.ExecuteCodeAction(
                    {
                        trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, 
                        parameter: { 
                                mesh: thisSpeedGround
                        }
                    },
                    (evt) => {
                        if(thisSpeedGround.checkCollisions){
                            console.log('izaso')
                            thisSpeedGround.checkCollisions = false;
                            playerSpeed += 0.2;
                            setTimeout(function(){
                            playerSpeed -= 0.2;
                            }, 4000)
                        }
                    }
                    );  
                    ellipse[j].actionManager.registerAction(action);
                }
            }
            
            //loop to ellipse to give action manager
            for (let z = 0; z < ellipse.length; z++) {
                ellipse[z].actionManager = new BABYLON.ActionManager(scene);
            }


            

            setInterval(function(){
            console.log(scene.meshes.length)
            console.log(fakeMesh.position.z)
        }, 500) 
            return scene;
            //END OF SCENE
        
        }
    window.initFunction = async function() {               
        var asyncEngineCreation = async function() {
            try {
                return createDefaultEngine();
                } catch(e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }

    window.engine = await asyncEngineCreation();
    if (!engine) throw 'engine should not be null.';
    window.scene = createScene();};
        
    initFunction().then(() => {sceneToRender = scene        
        engine.runRenderLoop(function () {
            if (sceneToRender && sceneToRender.activeCamera) {
                sceneToRender.render();
            }
        });
    });

    // Resize
    window.addEventListener("resize", function () {
            engine.resize();
    });




    </script>
</body>
</html>
