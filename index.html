<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <!-- HAMMER - TOUCH EVENT LIBRARY -->
        <script src="https://hammerjs.github.io/dist/hammer.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
<div id='container' style="width: 100vw; height: 100vh;">
    <canvas id="renderCanvas"></canvas>
    <p id='fps' style="position: absolute; top: 80%; left: 10%; font-size: 100px; color: white;">1111</p>
</div> 
    <script>
        var fps = document.getElementById('fps');
        setInterval(function(){ 
           fps.innerHTML = engine.getFps()
            }, 500)
        setInterval
        //GET CANVAS
        var container = document.getElementById("container");
        var canvas = document.getElementById("renderCanvas");


    var startAgain = document.createElement("DIV");
    startAgain.style.width = "40%"
    startAgain.style.height = "9.5%"
    startAgain.style.position = 'absolute';
    startAgain.style.left = '30%';
    startAgain.style.top = '30%';
    startAgain.style.backgroundImage = 'url("img/startAgain2.png")';
    startAgain.style.backgroundSize = 'cover';
    startAgain.style.backgroundPosition = 'center';
    startAgain.style.display = 'none';
    container.append(startAgain);

    startAgain.onclick = () => {
        // startAgain.style.display = 'none';
        location.reload();
    }


    //BABYLON START

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };

        //for loading
            BABYLON.DefaultLoadingScreen.prototype.displayLoadingUI = function () {
                if (document.getElementById("customLoadingScreenDiv")) {
                    // Do not add a loading screen if there is already one
                    document.getElementById("customLoadingScreenDiv").style.display = "initial";
                    return;
                }
                this._loadingDiv = document.createElement("div");
                this._loadingDiv.id = "customLoadingScreenDiv";
                // this._loadingDiv.innerHTML = "scene is currently loading";
                var customLoadingScreenCss = document.createElement('style');
                customLoadingScreenCss.type = 'text/css';
                // if (document.body.clientWidth < 768) {
                    console.log(document.body.clientWidth)
                // }
                if(document.body.clientWidth > document.body.clientHeight){
                customLoadingScreenCss.innerHTML = `
                #customLoadingScreenDiv{
                    background-image: url("img/loadingBackgroundDes.gif");
                    background-size: cover;
                    background-position: center;
                }
                 `;} else {
                    customLoadingScreenCss.innerHTML = `
                #customLoadingScreenDiv{
                    background-image: url("img/loadingBackgroundMob.gif");
                    background-size: cover;
                    background-position: center;
                }
                 `;
                 }
                document.getElementsByTagName('head')[0].appendChild(customLoadingScreenCss);
                this._resizeLoadingUI();
                window.addEventListener("resize", this._resizeLoadingUI);
                document.body.appendChild(this._loadingDiv);
            };

            BABYLON.DefaultLoadingScreen.prototype.hideLoadingUI = function(){
                document.getElementById("customLoadingScreenDiv").style.display = "none";
                console.log("scene is now loaded");
            }
        //end of loading

    //START GAME
        function createScene() {
            
            // for loading
            engine.displayLoadingUI();
            
            var scene = new BABYLON.Scene(engine);

            //PAUSE GAME

            // listenOtherEvents() {
            //     window.addEventListener('blur', () => {
            //         this.pause();
            //     });

            //     window.addEventListener('focus', () => {
            //         this.resume();
            //     });
            // }

            //LIGHT
            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, -1), scene);
            light.intensity = 1;
            var light2 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 1), scene);
            light2.intensity = 1;
            var light3 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, -1, -1), scene);
            light3.intensity = 1;
            var light4 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, -1, 1), scene);
            light4.intensity = 1;
            

            // CAMERA MAIN

            //movement camera
            // var camera = new BABYLON.UniversalCamera("MyCamera", new BABYLON.Vector3(0, 1, 0), scene);
            // camera.minZ = 0.0001;
            // camera.attachControl(canvas, true);
            // camera.speed = 0.005;
            // camera.angularSpeed = 0.02;
            // camera.angle = Math.PI/2;
            // camera.direction = new BABYLON.Vector3(Math.cos(camera.angle), 0, Math.sin(camera.angle));
            
            // //view camera
            // var viewCamera = new BABYLON.UniversalCamera("viewCamera", new BABYLON.Vector3(0, 2, -5), scene);
            // viewCamera.parent = camera;
            // viewCamera.setTarget(new BABYLON.Vector3(0, -0.0001, 1));
            
            // //Activate both cameras
            // scene.activeCameras.push(camera);
            // scene.activeCameras.push(viewCamera);//shoud be second

            //test
            // var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 2, -5), scene);
            // camera.attachControl(canvas, true);
            //rotate camera
            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 3, -5));
            

            //MOVMENT OF THE CAMERA
            //movment of viper and view camrera
            // scene.beforeRender = function() {
                // camera.rotation.y = 0;
                // camera.rotation.x = 0;
                // camera.position.z += 0.2;
            // };
            
            
            //GUI
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            //START PANEL
            // var startPanel = new BABYLON.GUI.StackPanel();
            // startPanel.width = 1;
            // startPanel.height = 1;
            // startPanel.isVertical = true;
            // startPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            // startPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            // advancedTexture.addControl(startPanel);
            //start image
            var viperDemo = new BABYLON.GUI.Image("", "img/vipermanDemo2.png");
            viperDemo.width = 0.8;
            viperDemo.height = 0.4;
            viperDemo.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            viperDemo.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            advancedTexture.addControl(viperDemo);
            //start game image
            var startGame = new BABYLON.GUI.Image("", "img/startGame2.png");
            startGame.width = 0.4;
            startGame.height = 0.1;
            startGame.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            startGame.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            startGame.isPointerBlocker = true;
            advancedTexture.addControl(startGame);
            //display pause sign
            var pauseGameSign = new BABYLON.GUI.Image("", "img/pause2.png");
            pauseGameSign.width = 0.4;
            pauseGameSign.height = 0.1;
            pauseGameSign.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            pauseGameSign.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            pauseGameSign.notRenderable = true;
            advancedTexture.addControl(pauseGameSign);
            //game over sign
            var gameOverSign = new BABYLON.GUI.Image("", "img/gameOver2.png");
            gameOverSign.width = 0.4;
            gameOverSign.height = 0.1;
            gameOverSign.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            gameOverSign.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            gameOverSign.notRenderable = true;
            advancedTexture.addControl(gameOverSign);
            //rotate around viper before start and at the end
            function rotateAroundMesh(){
                scene.onBeforeCameraRenderObservable.add(()=>{
                    if (!gameRunning){
                        scene.activeCamera.alpha += .002;
                    }
                })
            }
             //pause game button
            var pauseGameButton = new BABYLON.GUI.Image("", "img/pauseButton.png");
            pauseGameButton.width = 0.025;
            pauseGameButton.height = 0.05;
            pauseGameButton.top = 20 + 'px';
            pauseGameButton.left = -20 + 'px';
            pauseGameButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            pauseGameButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            pauseGameButton.isPointerBlocker = true;
            advancedTexture.addControl( pauseGameButton);
            //start game from pause button
            var startGameFromPauseButton = new BABYLON.GUI.Image("", "img/playButton.png");
            startGameFromPauseButton.width = 0.025;
            startGameFromPauseButton.height = 0.05;
            startGameFromPauseButton.top = 20 + 'px';
            startGameFromPauseButton.left = -20 + 'px';
            startGameFromPauseButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            startGameFromPauseButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            startGameFromPauseButton.isPointerBlocker = true;
            startGameFromPauseButton.notRenderable = true;
            advancedTexture.addControl(startGameFromPauseButton);

            // startGame.notRenderable = true;
            // viperDemo.notRenderable = true;

            //COINS, LIVES AND RUNNING MESH STATUS
            var gameRunning = false;
            var running = false;
            var lives = 3;
            var colectedCoins = 0;
            //LIFE AND COINS DISPLAY
            //lives display
            var lifesHolder = new BABYLON.GUI.Rectangle();
            lifesHolder.thickness = 0;
            lifesHolder.width = 60 + 'px';
            lifesHolder.height = 40 + 'px';
            lifesHolder.left = 20 + 'px';
            lifesHolder.top = 20 + 'px';
            lifesHolder.background = "black";
            lifesHolder.alpha = 0.4;
            lifesHolder.cornerRadius = 15;
            lifesHolder.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            lifesHolder.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            advancedTexture.addControl(lifesHolder);

            var livesBlock = new BABYLON.GUI.TextBlock();
            livesBlock.text = "x3";
            livesBlock.color = "#fff";
            livesBlock.fontSize = 25 + "px";
            livesBlock.alpha = 2.5;
            lifesHolder.addControl(livesBlock);
            //coins display
            var coinsHolder = new BABYLON.GUI.Rectangle();
            coinsHolder.thickness = 0;
            coinsHolder.width = 120 + 'px';
            coinsHolder.height = 40 + 'px';
            coinsHolder.left = 20 + 'px';
            coinsHolder.top = 70 + 'px';
            coinsHolder.background = "black";
            coinsHolder.alpha = 0.4;
            coinsHolder.cornerRadius = 15;
            coinsHolder.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            coinsHolder.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            advancedTexture.addControl(coinsHolder);

            var imageLogo = new BABYLON.GUI.Image("imageLogo", "img/sandviperLogo.png");
            imageLogo.width = 70 + 'px';
            imageLogo.height = 70 + 'px';
            imageLogo.left = -25 + 'px';
            imageLogo.alpha = 2.5;
            coinsHolder.addControl(imageLogo);

            var coinBlock = new BABYLON.GUI.TextBlock();
            coinBlock.text = ": 0";
            coinBlock.color = "#fff";
            coinBlock.fontSize = 25 + "px";
            coinBlock.left = 15 + 'px';
            coinBlock.alpha = 2.5;
            coinsHolder.addControl(coinBlock);
            
            //MUSIC IN THE GAME
            // var gameMusic = new BABYLON.Sound("gameMusic", "sounds/TRON Legacy (End Titles).mp3", scene, null, {
            //     loop: true,
            //     autoplay: true
            // });

            // HDR texture of background
            var hdrBcgRefTexture = new BABYLON.HDRCubeTexture("textures/shangai.hdr", scene, 128);

            // Skybox
            var hdrSkybox = BABYLON.Mesh.CreateBox("hdrSkyBox", 5000.0, scene);
            var hdrSkyboxMaterial = new BABYLON.PBRMaterial("skyBox", scene);
            hdrSkyboxMaterial.backFaceCulling = false;
            hdrSkyboxMaterial.reflectionTexture = hdrBcgRefTexture.clone();
            hdrSkyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            hdrSkyboxMaterial.microSurface = 1.0;
            hdrSkyboxMaterial.cameraExposure = 0.66;
            hdrSkyboxMaterial.cameraContrast = 1.66;
            hdrSkyboxMaterial.disableLighting = true;
            hdrSkybox.material = hdrSkyboxMaterial;
            hdrSkybox.infiniteDistance = true;
            
            //GIVE GLOW TO GLOWING OBJ
            var glow = new BABYLON.GlowLayer("glow", scene);
            glow.intensity = 0.8;

            //fake mesh for camera
            var fakeMesh = new BABYLON.MeshBuilder.CreateBox("fakeMesh", {width: 0.2, height: 0.2, depth: 0.2}, scene);
            fakeMesh.position = new BABYLON.Vector3(0,1.8,0)
            fakeMesh.isVisible = false;
            camera.target = fakeMesh;
            //fake mesh for elipsoid
            var fakeMeshEllipse = new BABYLON.MeshBuilder.CreateBox("fakeMeshEllipse", {width: 0.2, height: 0.2, depth: 0.2}, scene);
            fakeMeshEllipse.position = new BABYLON.Vector3(0,-0.8,0)
            fakeMeshEllipse.parent = fakeMesh;
            fakeMeshEllipse.isVisible = false;

            //Create Ellipsoid around mesh
            var a = 0.5;
            var b = 1;
            var points = [];
            for(var theta = -Math.PI/2; theta < Math.PI/2; theta += Math.PI/36) {
                points.push(new BABYLON.Vector3(0, b * Math.sin(theta), a * Math.cos(theta)));
            }
            var ellipse = [];
            ellipse[0] = BABYLON.MeshBuilder.CreateLines("e", {points:points}, scene);
            ellipse[0].isVisible = false;
            ellipse[0].parent = fakeMeshEllipse;
            ellipse[0].rotation.y = 5 * Math.PI/ 16;
            for(var i = 1; i < 23; i++) {
                ellipse[i] = ellipse[0].clone("el" + i);
                ellipse[i].parent = fakeMeshEllipse;
                ellipse[i].rotation.y = 5 * Math.PI/ 16 + i * Math.PI/16;
                ellipse[i].isVisible = false;
                ellipse[i].checkCollisions = true;
            }
                

            //IMPORT VIPERMAN MESH
            //viperman
            BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/veljko85/glbModels/gh-pages/viperman/", "viperman.glb").then((result) => {
            // BABYLON.SceneLoader.ImportMeshAsync("", "", "meshes/viperman.glb").then((result) => { 
                var viperman =  result.meshes[0];
                viperman.parent = fakeMesh;
                viperman.position.y = -1.8;
                
                //VIPER MESH IMPORT ANIMATION
                //run animation
                var runAnim = scene.animationGroups.find(a => a.name === 'run');
                var runParam = { name: "Run", anim: runAnim, weight: 0 };
                runAnim.setWeightForAllAnimatables(1);
                
                //jump animation
                var jumpAnim = scene.animationGroups.find(a => a.name === 'jump');
                var jumpParam = { name: "Jump", anim: jumpAnim, weight: 0 };
                jumpAnim.setWeightForAllAnimatables(0);
                //hit animation
                var hitAnim = scene.animationGroups.find(a => a.name === 'hit_in');
                var hitParam = { name: "Hit", anim: hitAnim, weight: 0 };
                hitAnim.setWeightForAllAnimatables(0);
                //finsh animation
                var finishAnim = scene.animationGroups.find(a => a.name === 'finish');
                var finishParam = { name: "Finish", anim: jumpAnim, weight: 0 };
                finishAnim.play(true);
                finishAnim.setWeightForAllAnimatables(0);
                //game over animation
                var gameOverAnim = scene.animationGroups.find(a => a.name === 'game_over');
                var gameOverParam = { name: "gameOver", anim: gameOverAnim, weight: 0 };
                gameOverAnim.setWeightForAllAnimatables(0);
                //start animation
                var startAnim = scene.animationGroups.find(a => a.name === 'start');
                var startParam = { name: "Start", anim: startAnim, weight: 0 };
                startAnim.setWeightForAllAnimatables(0);
                //slide animation
                var slideAnim = scene.animationGroups.find(a => a.name === 'slide');
                var slideParam = { name: "Slide", anim: slideAnim, weight: 0 };
                slideAnim.setWeightForAllAnimatables(0);
                
                //VIPER MESH BABYLON.JS CREATED ANIMATION
                //move left and right
                function moveViperAnim(mesh, pos, direction){
                    const anim= new BABYLON.Animation("moveLeftAnim", "position.x", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    anim.setKeys([
                        { frame: 0, value: pos },
                        { frame: 15, value: direction },
                    ]);
                    mesh.animations = [];
                    mesh.animations.push(anim);
                    return scene.beginAnimation(mesh, 0, 15, false);
                }
                //jump animation
                function aniPosY(mesh, meshPosition){
                    const anim= new BABYLON.Animation("animPosY", "position.y", 45, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    anim.setKeys([
                        { frame: 0, value: meshPosition + 0 },
                        { frame: 10, value: meshPosition + 3 },
                        { frame: 18, value: meshPosition + 3.5 },
                        { frame: 20, value: meshPosition + 3.5 },
                        { frame: 30, value: meshPosition + 0 },
                    ]);
                    mesh.animations = [];
                    mesh.animations.push(anim);
                    return scene.beginAnimation(mesh, 0, 30, false);
                }
                //VIPER REACTIONS FUNTIONS ON EVENT LISTENERS
                function viperJump(){
                    if (fakeMesh.position.x == 0 || fakeMesh.position.x == -3 || fakeMesh.position.x == 3) {
                        //jumpSound.play();
                        aniPosY(fakeMesh, 1.8)
                        jumpAnim.start(false, 1.66, 0);
                        runAnim.setWeightForAllAnimatables(0);
                        running = false;
                        setTimeout(function(){ 
                            running = true;
                            runAnim.setWeightForAllAnimatables(1);
                        }, 633)
                    }
                }
                
                function viperMoveLeft(){
                    if (fakeMesh.position.x == 0 || fakeMesh.position.x == 3) {
                        moveViperAnim(fakeMesh, fakeMesh.position.x, fakeMesh.position.x-3)
                            fakeMesh.addRotation(0,-0.3,0)
                        setTimeout(function(){ 
                            fakeMesh.addRotation(0,0.3,0)
                        }, 250)
                    }
                }
                function viperMoveRight(){
                    if (fakeMesh.position.x == 0 || fakeMesh.position.x == -3) {
                        moveViperAnim(fakeMesh, fakeMesh.position.x, fakeMesh.position.x+3)
                            fakeMesh.addRotation(0,0.3,0)
                        setTimeout(function(){ 
                            fakeMesh.addRotation(0,-0.3,0)
                        }, 250)
                    }
                }
                function viperSlide(){
                    if (fakeMesh.position.x == 0 || fakeMesh.position.x == -3 || fakeMesh.position.x == 3) {
                        slideAnim.start(false, 1, 0);
                        runAnim.setWeightForAllAnimatables(0);
                        fakeMeshEllipse.position.y = -1.8;
                        running = false;
                        setTimeout(function(){ 
                            running = true;
                            fakeMeshEllipse.position.y = -0.8;
                            runAnim.setWeightForAllAnimatables(1);
                        }, 1580)
                    }
                }
                //EVENT LISTENERS
                //key event listeners
                function lintenKeysEvents(){
                    document.onkeydown = checkKey;
                    function checkKey(event) {
                        if (event.keyCode == 38 && running) {
                            viperJump();
                        }
                        //jump on ins0
                        if (event.keyCode == 96 && running) {
                            viperJump();
                        }
                        //viper move left
                        if (event.keyCode == 37 && running) {
                            viperMoveLeft();
                        }
                        //viper move right
                        if (event.keyCode == 39 && running) {
                            viperMoveRight();
                        }
                        //viper slide down
                        if (event.keyCode == 40 && fakeMeshEllipse.position.y == -0.8 && running) {
                            viperSlide();
                        }
                    }
                }
                //touch event listeners with hammer
                function lintenTouchEvents(){
                    var hammertime = new Hammer(canvas);
                    hammertime.get('swipe').set({ direction: Hammer.DIRECTION_ALL });
                    hammertime.on("swipeleft swiperight swipeup swipedown tap press", function(ev) {
                        if (ev.type == 'swipeup'  && running){
                            viperJump(); 
                        } else if (ev.type == 'swipedown'  && running) {
                            viperSlide();
                        }
                        else if (ev.type == 'swipeleft'  && running) {
                            viperMoveLeft();
                        }
                        else if (ev.type == 'swiperight'  && running) {
                            viperMoveRight();
                        }
                    });
                }
                
                //viper moving true track function
                function meshRunning(){
                    //change running status
                    running = true;
                    gameRunning = true;
                    if (fakeMesh.position.z < -4.9){
                        camera.setPosition(new BABYLON.Vector3(0, 3, -5));
                    } else {
                        camera.setPosition(new BABYLON.Vector3(fakeMesh.position.x, 3, fakeMesh.position.z - 5));
                    }
                    //start running animation
                    runAnim.start(true, 1, 0);
                    //change viperman and fake mesh position z - move thrue space
                    scene.beforeRender = function() {
                        fakeMesh.position.z += 0.2;
                    };
                    //assign event listeners to mesh when running
                }
                
                //pause game function
                function pauseGame(){ 
                    if (gameRunning){
                        running = false;
                        gameRunning = false;
                        runAnim.pause(true);
                        scene.beforeRender = function() {
                            fakeMesh.position.z += 0;
                        };
                        pauseGameButton.notRenderable = true;
                        startGameFromPauseButton.notRenderable = false;
                        pauseGameSign.notRenderable = false;
                    }
                }

                //start game from pause function
                function startGameFromPause(){ 
                    if (!gameRunning){ 
                        gameRunning = true;
                        runAnim.pause(false);
                        runAnim.play(true);
                        meshRunning()
                        pauseGameButton.notRenderable = false;
                        startGameFromPauseButton.notRenderable = true;
                        pauseGameSign.notRenderable = true;
                    }
                }
                //pause game
                pauseGameButton.onPointerClickObservable.add(function () {
                    pauseGame();
                });
                //start game from pause
                startGameFromPauseButton.onPointerClickObservable.add(function () {
                    startGameFromPause();
                });
                //rotate around the mesh at start and end of the game
                rotateAroundMesh()
                //START GAME
                startGame.onPointerClickObservable.add(function () {
                    meshRunning();
                    viperDemo.notRenderable = true;
                    startGame.notRenderable = true;
                    lintenKeysEvents();
                    lintenTouchEvents();
                });

                //for loading
                engine.hideLoadingUI();
                
            });

            //game over function
            function gameOver(){ 
                running = false;
                gameRunning = false;
                gameOverSign.notRenderable = false;
                scene.animationGroups.find(a => a.name === 'run').pause(true);
                scene.beforeRender = function() {
                    fakeMesh.position.z += 0;
                };
                startAgain.style.display = 'block';
            }
                         
            //CREATE BRIDGE-PATH FOR VIPER TO RUN
            function createRunningTrack(){
                
                //main platform for running
                var bridge = BABYLON.MeshBuilder.CreateGround("ground", {width: 9, height:1000}, scene);
                var bridgeMat = new BABYLON.PBRMaterial("bridgeMat", scene);
                // bridgeMat.reflectionTexture = hdrBcgRefTexture;
                // bridgeMat.refractionTexture = hdrBcgRefTexture;
                // bridgeMat.reflectionTexture.level = 1;
                // bridgeMat.specularPower = 150;
                // bridgeMat.indexOfRefraction = 0.52;
                // bridgeMat.alpha = 0.8;
                // bridgeMat.directIntensity = 0.0;
                // bridgeMat.environmentIntensity = 0.7;
                // bridgeMat.cameraExposure = 0.66;
                // bridgeMat.cameraContrast = 1.66;
                bridge.material = bridgeMat;
                bridge.position.z = 490;

                //create bridge plane to go bellow
                var bridgeLayout = BABYLON.MeshBuilder.CreateGround("ground", {width: 10.5, height:1000}, scene);
                bridgeLayout.position.z = 490;
                bridgeLayout.position.y = -0.5;
                var bridgeLayoutMat = new BABYLON.StandardMaterial("bridgeLayoutMat", scene);
                bridgeLayoutMat.diffuseTexture = new BABYLON.Texture("img/podloga3.jpg", scene);
                bridgeLayoutMat.diffuseTexture.uScale = 1;
                bridgeLayoutMat.diffuseTexture.vScale = 200;
                bridgeLayout.material = bridgeLayoutMat;


                //create glass walls
                var glassWall = new BABYLON.MeshBuilder.CreateBox("glassWall", {width: 0.05, height: 3, depth: 1000}, scene);
                glassWall.position = new BABYLON.Vector3(-5,1.5,490)
                var glassWallMat = new BABYLON.PBRMaterial("glassWallMat", scene);
                // glassWallMat.reflectionTexture = hdrBcgRefTexture;
                // glassWallMat.refractionTexture = hdrBcgRefTexture;
                // glassWallMat.linkRefractionWithTransparency = true;
                // glassWallMat.indexOfRefraction = 0.52;
                // glassWallMat.alpha = 0;
                // glassWallMat.directIntensity = 0.0;
                // glassWallMat.environmentIntensity = 0.7;
                // glassWallMat.cameraExposure = 0.66;
                // glassWallMat.cameraContrast = 1.66;
                // glassWallMat.reflectivityColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                // glassWallMat.albedoColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                glassWall.material = glassWallMat;
                //other glass walls
                var glassWall2 = glassWall.clone("glassWall2");
                glassWall2.position.x = 5;
            
                //side walks
                var sideWalk = new BABYLON.MeshBuilder.CreateBox("sideWalk", {width: 1, height: 0.4, depth: 1000}, scene);
                var sideWalkMat = new BABYLON.StandardMaterial("sideWalkMat", scene);
                sideWalkMat.diffuseColor = new BABYLON.Color3.FromHexString('#00cdcd')
                sideWalkMat.emissiveColor = new BABYLON.Color3.FromHexString('#00cdcd');
                // sideWalkMat.diffuseColor = new BABYLON.Color3.FromHexString('#cd00cd')
                // sideWalkMat.emissiveColor = new BABYLON.Color3.FromHexString('#cd00cd');
                sideWalk.material = sideWalkMat;
                sideWalk.position = new BABYLON.Vector3(-5,0,490)
                //other sidewalk
                var sideWalk2 = sideWalk.clone("sideWalk2");
                sideWalk2.position.x = 5;
                //side walks glass part
                var sideWalkGlassPart = new BABYLON.MeshBuilder.CreateBox("sideWalkGlassPart", {width: 0.1, height: 0.1, depth: 1000}, scene);
                sideWalkGlassPart.material = glassWallMat;
                sideWalkGlassPart.position = new BABYLON.Vector3(-4.5,0.2,490)
                //other sidewalk glass part
                var sideWalkGlassPart2 = sideWalkGlassPart.clone("sideWalkGlassPart2");
                sideWalkGlassPart2.position.x = 4.5;
                
                //running tracks
                var runningTrack = new BABYLON.MeshBuilder.CreateBox("runningTrack", {width: 0.2, height: 0.1, depth: 1000}, scene);
                var runningTrackMat = new BABYLON.StandardMaterial("runningTrackMat", scene);
                runningTrackMat.emissiveColor = new BABYLON.Color3.FromHexString('#00cdcd');
                runningTrack.material = runningTrackMat;
                runningTrack.position = new BABYLON.Vector3(-1.5,0,490)
                //right running track
                var runningTrackRight = runningTrack.clone("runningTrackRight");
                runningTrackRight.position.x = 1.5;
                //running tracks glass part
                var runningGlassPart = sideWalkGlassPart.clone("runningGlassPart");
                runningGlassPart.position = new BABYLON.Vector3(-1.5,0.05,490)
                //running tracks glass part right
                var runningGlassPartRight = sideWalkGlassPart.clone("runningGlassPartRight");
                runningGlassPartRight.position = new BABYLON.Vector3(1.5,0.05,490)

                //SANDVIPER LOGO FOR COINS
                BABYLON.SceneLoader.ImportMeshAsync("", "", "meshes/logo.glb").then((result) => { 
                    var coinLogo = result.meshes[0];
                    coinLogo.position = new BABYLON.Vector3(0,-5,15)
                    var coinLogoMat = new BABYLON.StandardMaterial("coinLogoMat", scene);
                    coinLogoMat.emissiveColor = new BABYLON.Color3.FromHexString('#ffffff');
                    scene.getMeshByName("Plane").material = coinLogoMat;
                    coinLogo.rotationQuaternion = null;
                    coinLogo.checkCollisions = true;
                    
                    coins = [];
                    function createCoinLane(coinLanePositionX, coinLanePositionZ){
                        for (var i = 1; i < 11; i++) {
                            var newCoin = coinLogo.clone("coin" + i);
                            coins.push(newCoin);
                            newCoin.position = new BABYLON.Vector3(coinLanePositionX, 0.5, (coinLanePositionZ + i * 3));
                        }
                    }
                    createCoinLane(3, 30);
                    createCoinLane(0.01, 100);
                    //coin colider
                    for (let j = 0; j < ellipse.length; j++) {
                        for (let i = 0; i < coins.length; i++) {
                            coins[i].checkCollisions = true;
                            coins[i].actionManager = new BABYLON.ActionManager(scene);
                                let action = new BABYLON.ExecuteCodeAction(
                                    {
                                        trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, 
                                        parameter: { 
                                            mesh: coins[i]
                                        }
                                    },
                                    (evt) => {
                                        if (coins[i].isVisible) { 
                                            colectedCoins += 1;
                                            // coinSound.play();
                                            coinBlock.text = ": " + colectedCoins;
                                            coins[i].isVisible = false;
                                            coins[i].setEnabled(false);
                                        }
                                    }
                                );  
                                ellipse[j].actionManager.registerAction(action);
                        }
                    }
                })
                //FOOES
                function aniLaserWallWidth(mesh){
                    const anim= new BABYLON.Animation("aniLaserWallWidth", "scaling", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    anim.setKeys([
                        { frame: 0, value: new BABYLON.Vector3(1, 1, 1) },
                        // { frame: 10, value: -1 },
                        // { frame: 18, value: -0.5 },
                        // { frame: 20, value: -0.5 },
                        { frame: 60, value: new BABYLON.Vector3(3, 3, 3) },
                    ]);
                    mesh.animations = [];
                    mesh.animations.push(anim);
                    return scene.beginAnimation(mesh, 0, 60, false);
                }
                function aniSimpleLaserWall(mesh){
                    const anim= new BABYLON.Animation("aniSimpleLaserWall", "position.y", 45, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    anim.setKeys([
                        { frame: 0, value: -1.5 },
                        // { frame: 10, value: -1 },
                        // { frame: 18, value: -0.5 },
                        // { frame: 20, value: -0.5 },
                        { frame: 30, value: 0 },
                    ]);
                    mesh.animations = [];
                    mesh.animations.push(anim);
                    return scene.beginAnimation(mesh, 0, 30, false);
                }
                //animate the mesh when it hits fooes to blink
                function visColAnim(mesh){
                    const anim= new BABYLON.Animation("visColAnim", "visibility", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                    const colKeys = [
                    { frame: 0, value: 1 },
                        { frame: 5, value: 0 },
                        { frame: 10, value: 1 },
                        { frame: 15, value: 0 },
                        { frame: 20, value: 1 },
                        { frame: 25, value: 0 },
                        { frame: 30, value: 1 },
                        { frame: 35, value: 0 },
                    ]; 
                    anim.setKeys(colKeys);
                    mesh.animations = [];
                    mesh.animations.push(anim);
                    return scene.beginAnimation(mesh, 0, 35, false);
                }
                //animate the mesh when it hits fooes to go back few steps
                function animPosZMeshCollision(mesh){
                    const anim= new BABYLON.Animation("animPosZMeshCollision", "position.z", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                        anim.setKeys([
                            {frame: 0, value: mesh.position.z},
                            {frame: 5, value: mesh.position.z - 3},
                            {frame: 30, value: mesh.position.z - 3},
                        ]);
                        mesh.animations = [];    
                        mesh.animations.push(anim);
                        return scene.beginAnimation(mesh, 0, 60, false);
                }

                var laserWallUpperHolderLeft = new BABYLON.MeshBuilder.CreateBox("laserWallUpperHolderLeft", {width: 0.1, height: 1.4, depth: 0.1}, scene);
                laserWallUpperHolderLeft.position = new BABYLON.Vector3(-1.5,0.7,0);
                laserWallUpperHolderLeft.material = glassWallMat;

                var laserWallUpperHolderRight = laserWallUpperHolderLeft.clone("laserWallUpperHolderRight");
                laserWallUpperHolderRight.position.x = 1.5;

                var laserWall = BABYLON.MeshBuilder.CreatePlane("laserWall", {height:1.4, width: 2.9});
                laserWall.position = new BABYLON.Vector3(0,0.7,0);
                var laserWallmat = new BABYLON.StandardMaterial("laserWallmat", scene);
                var tex = new BABYLON.Texture("img/laserWall2.png", scene);
                tex.hasAlpha = true;
                laserWallmat.diffuseTexture = tex;
                laserWallmat.useAlphaFromDiffuseTexture = true;
                laserWallmat.backFaceCulling = false;
                laserWallmat.emissiveColor = new BABYLON.Color3.FromHexString('#DF740C')
                laserWall.material = laserWallmat;

                var simpleLaserWall = BABYLON.Mesh.MergeMeshes([laserWallUpperHolderLeft, laserWallUpperHolderRight, laserWall], true, true, undefined, false, true);
                simpleLaserWall.position = new BABYLON.Vector3(-3,-5,10)

                //array to put fooes
                fooes = [];
                //function to create simple wall
                function createSimpleLaserWall(SimpleLaserWallLanePositionX, SimpleLaserWallLanePositionZ, wideOfWall){      
                    var newSimpleLaserWall = simpleLaserWall.clone("simpleLaserWall");
                    fooes.push(newSimpleLaserWall);
                    newSimpleLaserWall.position = new BABYLON.Vector3(SimpleLaserWallLanePositionX, 0, SimpleLaserWallLanePositionZ);
                    newSimpleLaserWall.scaling = new BABYLON.Vector3(wideOfWall,1,1)
                }
                var randNum = () =>{
                    return Math.floor(Math.random() * 3);
                }
                
                var fooesLanePositions = [-3, 0, 3]
                var laserWallWidth = () => {

                }
                for (let i = 0; i < 10; i++) {
                    createSimpleLaserWall(fooesLanePositions[randNum()], 50 + i * 30, 1);
                }
                
                //fooes colider
                for (let f = 0; f < ellipse.length; f++) {
                    ellipse[f].actionManager = new BABYLON.ActionManager(scene);
                    for (let i = 0; i < fooes.length; i++) {
                        fooes[i].checkCollisions = true;
                        fooes[i].actionManager = new BABYLON.ActionManager(scene);
                            let action = new BABYLON.ExecuteCodeAction(
                                {
                                    trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, 
                                    parameter: { 
                                        mesh: fooes[i]
                                    }
                                },
                                (evt) => {
                                    if (fooes[i].checkCollisions){
                                        //give mesh animation to go back on collision
                                        
                                        // animPosZMeshCollision(scene.getMeshByUniqueId(153))
                                        animPosZMeshCollision(fakeMesh)
                                        fakeMesh.position.x = fooes[i].position.x;
                                        fakeMesh.position.y = 1.8;
                                        //give mesh animation to blink on collision
                                        visColAnim(fooes[i])
                                        // visColAnim(scene.getMeshByUniqueId(156))
                                        // visColAnim(scene.getMeshByUniqueId(160))
                                        fooes[i].checkCollisions = false;
                                        lives -= 1;
                                        livesBlock.text = "x" + lives;
                                        // hitWallSound.play();
                                        if (lives > 0){
                                            scene.animationGroups.find(a => a.name === 'run').stop(true, 1, 0)
                                            scene.animationGroups.find(a => a.name === 'hit_in').start(false, 1, 0)
                                            running = false;
                                            setTimeout(function(){
                                                scene.animationGroups.find(a => a.name === 'hit_in').stop(false, 1, 0)
                                                scene.animationGroups.find(a => a.name === 'run').start(true, 1, 0)
                                                running = true;
                                            }, 1000);
                                        }
                                        if (lives < 1){;
                                            scene.animationGroups.find(a => a.name === 'game_over').start(false, 1, 0)
                                            gameOver();
                                        }
                                        
                                    }
                                }
                            );  
                            ellipse[f].actionManager.registerAction(action);
                    }
                }
            }








                
                createRunningTrack()

            console.log(scene.meshes.length)
            
            
            
            
            
            console.log(canvas.width);
                console.log(navigator.userAgent);
                


            return scene;
            //END OF SCENE
        
        }
function initGame(){
    window.initFunction = async function() {               
        var asyncEngineCreation = async function() {
            try {
                return createDefaultEngine();
                } catch(e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }

    window.engine = await asyncEngineCreation();
    if (!engine) throw 'engine should not be null.';
    window.scene = createScene();};
        
    initFunction().then(() => {sceneToRender = scene        
        engine.runRenderLoop(function () {
            if (sceneToRender && sceneToRender.activeCamera) {
                sceneToRender.render();
            }
        });
    });

    // Resize
    window.addEventListener("resize", function () {
            engine.resize();
    });
}
initGame()


    </script>
</body>
</html>