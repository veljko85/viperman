<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Viperman</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <!-- HAMMER - TOUCH EVENT LIBRARY -->
        <script src="https://hammerjs.github.io/dist/hammer.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
<div id='container' style="width: 100vw; height: 100vh; overflow: hidden;">
    <canvas id="renderCanvas"></canvas>
    <p id='fps' style="position: absolute; top: 80%; left: 40%; font-size: 50px; color: white;">1111</p>
</div> 
    <script>

var fps = document.getElementById('fps');
        setInterval(function(){ 
           fps.innerHTML = engine.getFps()
        //    console.log(scene.getAnimationRatio())
            }, 1000)

        //GET CANVAS
        var container = document.getElementById("container");
        var canvas = document.getElementById("renderCanvas");




        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };

        function createScene() {
            var scene = new BABYLON.Scene(engine);

            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, -1), scene);
            light.intensity = 1;
            var light2 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 1), scene);
            light2.intensity = 1;
            var light3 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, -1, -1), scene);
            light3.intensity = 1;
            var light4 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, -1, 1), scene);
            light4.intensity = 1;

            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), scene);
            camera.setPosition(new BABYLON.Vector3(0, 3, -5));

            var fakeMesh = new BABYLON.MeshBuilder.CreateBox("fakeMesh", {width: 0.02, height: 0.02, depth: 0.02}, scene);
            var fakeMeshPosY = 0.18;
            fakeMesh.position = new BABYLON.Vector3(0,fakeMeshPosY,0)
            // fakeMesh.isVisible = false;
            camera.target = fakeMesh;

            //game info
            var gameRunning = false;
            var running = false;
            var highlandOnSideLeft = false;
            var highlandOnSideRight = false;
            var playerSpeed = 0.2;
            var lives = 3;
            var colectedCoins = 0;
            
            //fake mesh for camera
            var fakeMesh = new BABYLON.MeshBuilder.CreateBox("fakeMesh", {width: 0.2, height: 0.2, depth: 0.2}, scene);
            var fakeMeshPosY = 1.8;
            fakeMesh.position = new BABYLON.Vector3(0,fakeMeshPosY,0)
            fakeMesh.isVisible = false;
            camera.target = fakeMesh;
            //fake mesh for elipsoid
            var fakeMeshEllipse = new BABYLON.MeshBuilder.CreateBox("fakeMeshEllipse", {width: 0.2, height: 0.2, depth: 0.2}, scene);
            fakeMeshEllipse.position = new BABYLON.Vector3(0,-0.8,0)
            fakeMeshEllipse.parent = fakeMesh;
            fakeMeshEllipse.isVisible = false;

            //Create Ellipsoid around mesh
            var a = 0.5;
            var b = 1;
            var points = [];
            for(var theta = -Math.PI/2; theta < Math.PI/2; theta += Math.PI/36) {
                points.push(new BABYLON.Vector3(0, b * Math.sin(theta), a * Math.cos(theta)));
            }
            var ellipse = [];
            ellipse[0] = BABYLON.MeshBuilder.CreateLines("e", {points:points}, scene);
            ellipse[0].isVisible = false;
            ellipse[0].parent = fakeMeshEllipse;
            ellipse[0].rotation.y = 5 * Math.PI/ 16;
            for(var i = 1; i < 23; i++) {
                ellipse[i] = ellipse[0].createInstance("el" + i);
                ellipse[i].parent = fakeMeshEllipse;
                ellipse[i].rotation.y = 5 * Math.PI/ 16 + i * Math.PI/16;
                ellipse[i].isVisible = false;
                ellipse[i].checkCollisions = true;
            }
                

            //IMPORT VIPERMAN MESH
            //viperman
            BABYLON.SceneLoader.ImportMeshAsync("", "https://raw.githubusercontent.com/veljko85/glbModels/gh-pages/viperman/", "viperman.glb").then((result) => {
            // BABYLON.SceneLoader.ImportMeshAsync("", "", "meshes/viperman.glb").then((result) => { 
                var viperman =  result.meshes[0];
                viperman.parent = fakeMesh;
                viperman.position.y = -1.8;
                // for (let i = 0; i < result.meshes.length; i++) {
                //     result.meshes[i].isVisible = false
                    
                // }
            })

            //MOVMENT
            //animation for moving left and right
            function moveViperAnim(mesh, pos, direction){
                const anim= new BABYLON.Animation("moveLeftAnim", "position.x", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                anim.setKeys([
                    { frame: 0, value: pos },
                    { frame: 15, value: direction },
                ]);
                mesh.animations = [];
                mesh.animations.push(anim);
                return scene.beginAnimation(mesh, 0, 15, false);
            }
            //function to move left
            function viperMoveLeft(){
                if (fakeMesh.position.x == 0 || fakeMesh.position.x == 3) {
                    moveViperAnim(fakeMesh, fakeMesh.position.x, fakeMesh.position.x-3)
                    fakeMesh.addRotation(0,-0.3,0)
                    setTimeout(function(){ 
                        fakeMesh.addRotation(0,0.3,0)
                    }, 250)
                }
            }
            //function to move right
            function viperMoveRight(){
                if (fakeMesh.position.x == 0 || fakeMesh.position.x == -3) {
                    moveViperAnim(fakeMesh, fakeMesh.position.x, fakeMesh.position.x+3)
                    fakeMesh.addRotation(0,0.3,0)
                    setTimeout(function(){ 
                        fakeMesh.addRotation(0,-0.3,0)
                    }, 250)
                }
            }
            //animation for jumping
            function aniPosY(mesh, meshPosition){
                const anim= new BABYLON.Animation("animPosY", "position.y", 45, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                anim.setKeys([
                    { frame: 0, value: meshPosition + 0 },
                    { frame: 10, value: meshPosition + 2.5 },
                    { frame: 20, value: meshPosition + 3 },
                    { frame: 30, value: meshPosition + 3.5 },
                ]);
                mesh.animations = [];
                mesh.animations.push(anim);
                return scene.beginAnimation(mesh, 0, 20, false);
            }
            //function for jumping
            function viperJump(){
                if (fakeMesh.position.x == 0 || fakeMesh.position.x == -3 || fakeMesh.position.x == 3) {
                    //jumpSound.play();
                    aniPosY(fakeMesh, fakeMeshPosY)
                    scene.animationGroups.find(a => a.name === 'jump').start(false, 1, 0);
                    scene.animationGroups.find(a => a.name === 'run').setWeightForAllAnimatables(0);
                    running = false;
                    setTimeout(function(){ 
                        running = true;
                        scene.animationGroups.find(a => a.name === 'run').setWeightForAllAnimatables(1);
                        scene.animationGroups.find(a => a.name === 'jump').stop(false, 1, 0);
                    }, 680)
                }
            }
            //function for sliding
            function viperSlide(){
                if (fakeMesh.position.x == 0 || fakeMesh.position.x == -3 || fakeMesh.position.x == 3) {
                    scene.animationGroups.find(a => a.name === 'slide').start(false, 1, 0);
                    scene.animationGroups.find(a => a.name === 'run').setWeightForAllAnimatables(0);
                    fakeMeshEllipse.position.y = -1.8;
                    running = false;
                    setTimeout(function(){ 
                        running = true;
                        fakeMeshEllipse.position.y = -0.8;
                        scene.animationGroups.find(a => a.name === 'run').setWeightForAllAnimatables(1);
                    }, 1580)
                }
            }
            
            //EVENT LISTENERS
            //key event listeners
            function lintenKeysEvents(){
                document.onkeydown = checkKey;
                function checkKey(event) {
                    if (event.keyCode == 38 && running) {
                        viperJump();
                    }
                    //jump on ins0
                    if (event.keyCode == 96 && running) {
                        viperJump();
                    }
                    //viper move left
                    if (event.keyCode == 37 && running && !highlandOnSideRight) {
                        viperMoveLeft();
                    }
                    //viper move right
                    if (event.keyCode == 39 && running && !highlandOnSideLeft) {
                        viperMoveRight();
                    }
                    //viper slide down
                    if (event.keyCode == 40 && fakeMeshEllipse.position.y == -0.8 && running) {
                        viperSlide();
                    }
                }
            }
            //touch event listeners with hammer
            function lintenTouchEvents(){
                var hammertime = new Hammer(canvas);
                hammertime.get('swipe').set({ direction: Hammer.DIRECTION_ALL });
                hammertime.on("swipeleft swiperight swipeup swipedown tap press", function(ev) {
                    if (ev.type == 'swipeup'  && running){
                        viperJump(); 
                    } else if (ev.type == 'swipedown'  && running) {
                        viperSlide();
                    }
                    else if (ev.type == 'swipeleft'  && running && !highlandOnSideRight) {
                        viperMoveLeft();
                    }
                    else if (ev.type == 'swiperight'  && running && !highlandOnSideLeft) {
                        viperMoveRight();
                    }
                });
            }
            //function for mesh to start running
            function meshRunning(){
                //change running status
                running = true;
                gameRunning = true;
                if (fakeMesh.position.z < -4.9){
                    camera.setPosition(new BABYLON.Vector3(0, 3, -5));
                } else {
                    camera.setPosition(new BABYLON.Vector3(fakeMesh.position.x, fakeMeshPosY + 1.2, fakeMesh.position.z - 5));
                }
                //start running animation
                scene.animationGroups.find(a => a.name === 'run').start(true, 1, 0);
                //change viperman and fake mesh position z - move thrue space
                scene.beforeRender = function() {
                    fakeMesh.position.z += playerSpeed * scene.getAnimationRatio();
                    // if(fakeMesh.position.y > fakeMeshPosY){
                    //     fakeMesh.position.y -= 0.2 * scene.getAnimationRatio();
                    // }
                    // if (fooes.length > 0) {
                    //     for (let i = 0; i < fooes.length; i++) {
                    //         if ((fakeMesh.position.z - 10) > fooes[i].position.z){
                    //         fooes[i].dispose();
                    //         }
                    //     }
                    // }
                    // if (coins.length > 0) {
                    //     for (let i = 0; i < coins.length; i++) {
                    //         if ((fakeMesh.position.z - 10) > coins[i].position.z){
                    //             coins[i].dispose();
                    //         }
                    //     }
                    // }
                    // if (stairsArr.length > 0) {
                    //     for (let i = 0; i < stairsArr.length; i++) {
                    //         if ((fakeMesh.position.z - 110) > stairsArr[i].position.z){
                    //             stairsArr[i].dispose();
                    //         }
                    //     }
                    // }
                };
            }

            //CREATE TRACK

            var track = BABYLON.MeshBuilder.CreateGround("ground", {width: 9, height:500}, scene);
            trackMat = new BABYLON.StandardMaterial("barrierMat", scene);
            trackMat.diffuseTexture = new BABYLON.Texture('textures/podlogaMain.gif', scene);
            trackMat.diffuseTexture.uScale = 2;
            trackMat.diffuseTexture.vScale = 200;

                track.material = trackMat;
                track.position.z = 240;

            setTimeout(function(){ 
            meshRunning();
            lintenKeysEvents();
            lintenTouchEvents();
            }, 2000)   

                


            return scene;
            //END OF SCENE
        
        }
    window.initFunction = async function() {               
        var asyncEngineCreation = async function() {
            try {
                return createDefaultEngine();
                } catch(e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }

    window.engine = await asyncEngineCreation();
    if (!engine) throw 'engine should not be null.';
    window.scene = createScene();};
        
    initFunction().then(() => {sceneToRender = scene        
        engine.runRenderLoop(function () {
            if (sceneToRender && sceneToRender.activeCamera) {
                sceneToRender.render();
            }
        });
    });

    // Resize
    window.addEventListener("resize", function () {
            engine.resize();
    });




    </script>
</body>
</html>
